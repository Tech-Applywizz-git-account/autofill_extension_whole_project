/**
 * Pattern Storage Service
 * Manages learned patterns with hybrid local/global storage
 */

import { PatternMatcher } from './patternMatcher';

export interface LearnedPattern {
    id: string;
    questionPattern: string;
    intent: string;
    canonicalKey: string;
    answerMappings?: AnswerMapping[];
    fieldType: string;
    confidence: number;
    usageCount: number;
    lastUsed: string;
    createdAt: string;
    source: 'AI' | 'manual';
    synced?: boolean;
}

export interface AnswerMapping {
    canonicalValue: string;
    variants: string[];
    contextOptions?: string[];
}

const API_BASE_URL = 'http://localhost:8001/api/patterns';

// Shareable intents (must match backend)
const SHAREABLE_INTENTS = [
    'eeo.gender', 'eeo.hispanic', 'eeo.veteran', 'eeo.disability', 'eeo.race', 'eeo.lgbtq',
    'workAuth.sponsorship', 'workAuth.usAuthorized', 'workAuth.driverLicense', 'workAuth.visaType',
    'location.country', 'location.state',
    'application.hasRelatives', 'application.previouslyApplied', 'application.ageVerification',
    'application.willingToRelocate', 'application.willingToTravel', 'application.workArrangement',
    // Pattern-only (no answer sharing)
    'personal.firstName', 'personal.lastName', 'personal.email', 'personal.phone', 'personal.city',
    'education.degree', 'education.school', 'education.major',
    'experience.company', 'experience.title'
];

export class PatternStorage {

    /**
     * Get all local patterns
     */
    async getLocalPatterns(): Promise<LearnedPattern[]> {
        try {
            const result = await chrome.storage.local.get('learnedPatterns');
            return result.learnedPatterns || [];
        } catch (error) {
            console.error('[PatternStorage] Error getting local patterns:', error);
            return [];
        }
    }

    /**
     * Save patterns locally
     */
    async saveLocalPatterns(patterns: LearnedPattern[]): Promise<void> {
        try {
            await chrome.storage.local.set({ learnedPatterns: patterns });
        } catch (error) {
            console.error('[PatternStorage] Error saving local patterns:', error);
        }
    }

    /**
     * Add a new pattern
     */
    async addPattern(pattern: Omit<LearnedPattern, 'id' | 'createdAt' | 'usageCount' | 'lastUsed'>): Promise<void> {
        const patterns = await this.getLocalPatterns();

        // Check if pattern already exists
        const existing = patterns.find(p =>
            p.intent === pattern.intent &&
            p.questionPattern.toLowerCase() === pattern.questionPattern.toLowerCase()
        );

        if (existing) {
            // Merge answer mappings
            if (pattern.answerMappings && existing.answerMappings) {
                pattern.answerMappings.forEach(newMapping => {
                    const existingMapping = existing.answerMappings!.find(
                        m => m.canonicalValue === newMapping.canonicalValue
                    );
                    if (existingMapping) {
                        newMapping.variants.forEach(v => {
                            if (!existingMapping.variants.includes(v)) {
                                existingMapping.variants.push(v);
                            }
                        });
                    } else {
                        existing.answerMappings!.push(newMapping);
                    }
                });
            }
            existing.lastUsed = new Date().toISOString();
            existing.synced = false; // Mark for re-sync
        } else {
            // Add new pattern
            const newPattern: LearnedPattern = {
                ...pattern,
                id: `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                usageCount: 0,
                createdAt: new Date().toISOString(),
                lastUsed: new Date().toISOString(),
                synced: false
            };
            patterns.push(newPattern);
            console.log(`[PatternStorage] ðŸŽ“ Learned new pattern: "${pattern.questionPattern}" â†’ ${pattern.intent}`);
        }

        await this.saveLocalPatterns(patterns);

        // Note: Pattern sharing removed - all patterns stored locally only
        // This ensures 100% reliability without network dependency
    }

    async findPattern(questionText: string): Promise<LearnedPattern | null> {
        // Search local patterns only (no network calls)
        const localPatterns = await this.getLocalPatterns();
        const localMatch = this.searchPatterns(localPatterns, questionText);

        if (localMatch) {
            console.log(`[PatternStorage] ðŸŽ“ Found local pattern for "${questionText}"`);
            await this.incrementUsage(localMatch.id);
            return localMatch;
        }

        return null;
    }

    /**
     * Search patterns locally with semantic matching
     */
    private searchPatterns(patterns: LearnedPattern[], questionText: string): LearnedPattern | null {
        // Normalize the incoming question (remove special chars)
        const qNormalized = this.normalizeQuestion(questionText);

        for (const pattern of patterns) {
            // Normalize stored pattern too
            const pNormalized = this.normalizePattern(pattern.questionPattern);

            // 1. Exact match after normalization
            if (pNormalized === qNormalized) {
                console.log(`[PatternStorage] âœ… Exact match: "${questionText}"`);
                return pattern;
            }

            // 2. Semantic keyword matching (NEW!)
            const semanticScore = this.calculateSemanticSimilarity(qNormalized, pNormalized);
            if (semanticScore >= 0.7) {
                console.log(`[PatternStorage] ðŸ§  Semantic match (${(semanticScore * 100).toFixed(0)}%): "${questionText}"`);
                return pattern;
            }

            // 3. Fallback to word overlap fuzzy match
            const wordOverlap = this.calculateWordOverlap(qNormalized, pNormalized);
            if (wordOverlap >= 0.6) {
                console.log(`[PatternStorage] ðŸŽ¯ Fuzzy match (${(wordOverlap * 100).toFixed(0)}%): "${questionText}"`);
                return pattern;
            }
        }

        return null;
    }

    /**
     * Calculate semantic similarity using keyword extraction
     * This is MUCH smarter than word overlap!
     */
    private calculateSemanticSimilarity(question1: string, question2: string): number {
        // Extract meaningful keywords (ignore common words)
        const keywords1 = this.extractKeywords(question1);
        const keywords2 = this.extractKeywords(question2);

        if (keywords1.length === 0 || keywords2.length === 0) {
            return 0;
        }

        // Count matching keywords
        let matchingKeywords = 0;
        for (const kw1 of keywords1) {
            for (const kw2 of keywords2) {
                // Exact match or one contains the other
                if (kw1 === kw2 || kw1.includes(kw2) || kw2.includes(kw1)) {
                    matchingKeywords++;
                    break; // Count each keyword only once
                }
            }
        }

        // Score = matching keywords / average keyword count
        const avgKeywordCount = (keywords1.length + keywords2.length) / 2;
        const score = matchingKeywords / avgKeywordCount;

        return score;
    }

    /**
     * Extract meaningful keywords from a question
     * Filters out common "stop words" that don't add meaning
     */
    private extractKeywords(text: string): string[] {
        // Common stop words to ignore
        const stopWords = new Set([
            'a', 'an', 'the', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
            'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'should', 'could',
            'may', 'might', 'must', 'can', 'of', 'at', 'by', 'for', 'with', 'about',
            'against', 'between', 'into', 'through', 'during', 'before', 'after',
            'to', 'from', 'in', 'out', 'on', 'off', 'over', 'under', 'again',
            'further', 'then', 'once', 'here', 'there', 'when', 'where', 'why',
            'how', 'all', 'both', 'each', 'few', 'more', 'most', 'other', 'some',
            'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than',
            'too', 'very', 's', 't', 'just', 'dont', 'now', 'but', 'or', 'and',
            'if', 'eg', 'i', 'you', 'your', 'we', 'they', 'them', 'their',
            'what', 'which', 'who', 'whom', 'this', 'that', 'these', 'those'
        ]);

        // Split into words, filter stop words, remove short words
        const words = text.toLowerCase().split(/\s+/);
        const keywords = words.filter(word =>
            word.length >= 3 &&           // At least 3 characters
            !stopWords.has(word) &&       // Not a stop word
            /[a-z]/.test(word)            // Contains letters
        );

        return keywords;
    }

    /**
     * Calculate word overlap similarity (old method, kept as fallback)
     */
    private calculateWordOverlap(str1: string, str2: string): number {
        const words1 = str1.split(/\s+/);
        const words2 = str2.split(/\s+/);

        const matchedWords = words1.filter(w => words2.includes(w)).length;
        return matchedWords / Math.max(words1.length, words2.length);
    }

    /**
     * Normalize question text for matching
     */
    private normalizeQuestion(questionText: string): string {
        return questionText.toLowerCase()
            .replace(/[*?!.,()]/g, '') // Remove special chars and punctuation
            .replace(/\s+/g, ' ') // Normalize whitespace
            .trim();
    }

    /**
     * Normalize pattern for matching
     */
    private normalizePattern(pattern: string): string {
        return pattern.toLowerCase()
            .replace(/[*?!.,()]/g, '') // Remove special chars and punctuation  
            .replace(/\s+/g, ' ') // Normalize whitespace
            .trim();
    }

    /**
     * Cache a pattern locally
     */
    private async cachePattern(pattern: LearnedPattern): Promise<void> {
        const patterns = await this.getLocalPatterns();

        // Check if already cached
        if (patterns.some(p => p.id === pattern.id)) {
            return;
        }

        patterns.push({ ...pattern, synced: true });
        await this.saveLocalPatterns(patterns);
    }

    /**
     * Increment usage count
     */
    async incrementUsage(patternId: string): Promise<void> {
        const patterns = await this.getLocalPatterns();
        const pattern = patterns.find(p => p.id === patternId);

        if (pattern) {
            pattern.usageCount++;
            pattern.lastUsed = new Date().toISOString();
            await this.saveLocalPatterns(patterns);
        }
    }





    /**
     * Get storage statistics
     */
    async getStats(): Promise<any> {
        const patterns = await this.getLocalPatterns();

        const intentBreakdown: any = {};
        patterns.forEach(p => {
            intentBreakdown[p.intent] = (intentBreakdown[p.intent] || 0) + 1;
        });

        return {
            totalPatterns: patterns.length,
            syncedPatterns: patterns.filter(p => p.synced).length,
            unsyncedPatterns: patterns.filter(p => !p.synced).length,
            totalUsage: patterns.reduce((sum, p) => sum + p.usageCount, 0),
            intentBreakdown
        };
    }
}

// Singleton instance
export const patternStorage = new PatternStorage();
